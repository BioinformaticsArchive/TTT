//    This file is part of TTT Tissue Tracker.
//
//    TTT Tissue Tracker is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    TTT Tissue Tracker is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with TTT Tissue Tracker.  If not, see <http://www.gnu.org/licenses/>.


#include <boost/graph/iteration_macros.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <vtkSphereSource.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkLineSource.h>
#include "PrimalGraphDrawer.h"

void PrimalGraphDrawer::Draw() {

	/*if(DoneTracking){
	 descriptor = observations[m_CurrentFrame];
	 }*/
	typedef itk::Point<double, 3> itkpt;
//	ProjectType::SpacingType s = m_Project.GetSpacing();
	//std::vector<double> s (0.28,0.28,0.32);
	std::cout << "size of SG "
			<< boost::num_vertices(m_Descriptor->m_SkeletonGraph) << std::endl;
	std::cout << "size of SG edges"
			<< boost::num_edges(m_Descriptor->m_SkeletonGraph) << std::endl;
	std::cout << "num V in SListS "
			<< boost::num_vertices(m_Descriptor->m_SkeletonGraph_listS)
			<< std::endl;
	std::cout << "num E in SListS "
			<< boost::num_edges(m_Descriptor->m_SkeletonGraph_listS) << std::endl;


	m_Actor2SkeletonVertex.clear();
	m_SkeletonEdge2Actor.clear();

	BGL_FORALL_VERTICES(v,m_Descriptor->m_SkeletonGraph,giaa::SkeletonGraph){
		itkpt a= boost::get(giaa::SkeletonPointPropertyTag(),m_Descriptor->m_SkeletonGraph,v).position;
		itkpt color = boost::get(giaa::SkeletonPointPropertyTag(),m_Descriptor->m_SkeletonGraph,v).color;
		vtkSmartPointer<vtkSphereSource> newSphere = vtkSmartPointer<vtkSphereSource>::New();
		newSphere->SetCenter(m_Spacing[0]*a[0],m_Spacing[1]*a[1],m_Spacing[2]*a[2]);
		//std::cout << v << " " << s[0]*a[0] << " " << s[1]*a[1] << " " << s[2]*a[2] << std::endl;
		newSphere->SetRadius(0.15);

		vtkSmartPointer<vtkPolyDataMapper> sphereMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
		sphereMapper->ImmediateModeRenderingOn();
		sphereMapper->SetInputConnection(newSphere->GetOutputPort());
		sphereMapper->ImmediateModeRenderingOn();
		vtkSmartPointer<vtkActor> sphereActor = vtkSmartPointer<vtkActor>::New();
		//std::cout << "primal " << v << " " << color[0] << " " << color[1] << " " << color[2] << std::endl;
		sphereActor->GetProperty()->SetColor(1,1,1);
		/*if(boost::degree(v,descriptor->m_SkeletonGraph) == 1){
	 	 	 sphereActor->GetProperty()->SetColor(1,0,0);
	 	 }
	 	if(boost::degree(v,descriptor->m_SkeletonGraph) == 2){
	 		sphereActor->GetProperty()->SetColor(0,1,0);
	 	 }
	 	 if(boost::degree(v,descriptor->m_SkeletonGraph) == 3){
	 	 	 sphereActor->GetProperty()->SetColor(0,0,1);
	 	 }
	 	 if(boost::degree(v,descriptor->m_SkeletonGraph) > 3){
	 	 	 sphereActor->GetProperty()->SetColor(0,0,0);
	 	 }*/

		sphereActor->SetMapper(sphereMapper);

		m_Actor2SkeletonVertex[sphereActor] = v;
		m_SkeletonVertex2Actor[v] = sphereActor;


		// giaaTovtkVertexToPrimal_ls[v] = sphereActor;
		m_Renderer->AddActor(sphereActor);
	}

	//this->CellBoundaryReduction();

	BGL_FORALL_EDGES(e,m_Descriptor->m_SkeletonGraph,giaa::SkeletonGraph){

		typedef itk::Point<double,3> itkpt;
		giaa::SkeletonVertexType src = boost::source(e,m_Descriptor->m_SkeletonGraph);
		giaa::SkeletonVertexType tgt = boost::target(e,m_Descriptor->m_SkeletonGraph);
		//std::cout<< "In edges " << src << " " << tgt << std::endl;
		vtkSmartPointer<vtkLineSource> newLine = vtkSmartPointer<vtkLineSource>::New();
		itkpt a= boost::get(giaa::SkeletonPointPropertyTag(),m_Descriptor->m_SkeletonGraph,boost::source(e,m_Descriptor->m_SkeletonGraph)).position;
		//std::cout<< a[0] << " " << a[1] << " " << a[2] << std::endl;
		//IndexType a=m_SkeletonGraph[].position;
		newLine->SetPoint1(a[0]*m_Spacing[0],a[1]*m_Spacing[1],a[2]*m_Spacing[2]);
		itkpt b= boost::get(giaa::SkeletonPointPropertyTag(),m_Descriptor->m_SkeletonGraph,boost::target(e,m_Descriptor->m_SkeletonGraph)).position;
		//IndexType b=m_SkeletonGraph[boost::target(e,)].position;
		newLine->SetPoint2(b[0]*m_Spacing[0],b[1]*m_Spacing[1],b[2]*m_Spacing[2]);
		vtkSmartPointer<vtkPolyDataMapper> mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
		mapper->ImmediateModeRenderingOn();
		mapper->SetInputConnection(newLine->GetOutputPort());
		vtkSmartPointer<vtkActor> actor = vtkSmartPointer<vtkActor>::New();
		actor->SetMapper(mapper);
		actor->GetProperty()->SetLineWidth(5);
		boost::tuple<giaa::SkeletonVertexType,giaa::SkeletonVertexType> pts (src,tgt);

		m_SkeletonEdge2Actor[pts] = actor;

		//std::cout<< src << " " << tgt << " "<< actor <<std::endl;
		boost::tuple<giaa::SkeletonVertexType,giaa::SkeletonVertexType> ptt (tgt,src);

		m_SkeletonEdge2Actor[ptt] = actor;

		m_Renderer->AddActor(actor);
	}
}

